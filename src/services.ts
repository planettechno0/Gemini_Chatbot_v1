// src/services.ts

import type { AppStateData, ChatMessage } from './state'; // Assuming types are in state.ts

// --- Gemini API Service ---

interface GeminiSafetySetting {
  category: string;
  threshold: string;
}

interface GeminiGenerationConfig {
  stopSequences?: string[];
  temperature?: number;
  maxOutputTokens?: number;
  topP?: number;
  topK?: number;
}

export interface GeminiRequestContent {
  role: 'user' | 'model';
  parts: (
    | { text: string }
    | { inlineData: { mimeType: string; data: string } }
  )[];
}

interface GeminiRequestPayload {
  contents: GeminiRequestContent[];
  safetySettings?: GeminiSafetySetting[];
  generationConfig?: GeminiGenerationConfig;
  systemInstruction?: { parts: { text: string }[] };
}

interface GeminiResponseData {
  candidates?: {
    content: GeminiRequestContent;
    finishReason?: string;
    index?: number;
    safetyRatings?: {
      category: string;
      probability: string;
      blocked?: boolean;
    }[];
  }[];
  promptFeedback?: {
    blockReason?: string;
    safetyRatings?: {
      category: string;
      probability: string;
    }[];
  };
}

export class GeminiAPIService {
  private readonly BASE_URL = 'https://generativelanguage.googleapis.com/v1beta/models/';

  async generateContent(
    model: string,
    payload: GeminiRequestPayload,
    apiKey: string
  ): Promise<GeminiResponseData> {
    const url = `${this.BASE_URL}${model}:generateContent?key=${apiKey}`;
    console.log('Gemini API Request:', { url, payload });

    try {
      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload),
      });

      const data: GeminiResponseData = await response.json();
      console.log('Gemini API Response:', data);

      if (!response.ok) {
        const errorDetails = data.promptFeedback?.blockReason || JSON.stringify(data, null, 2);
        throw new Error(`API Error: ${response.status} ${response.statusText}. Details: ${errorDetails}`);
      }
      if (data.promptFeedback?.blockReason) {
        console.warn('Content blocked by API:', data.promptFeedback.blockReason);
        // Potentially throw a custom error or return a specific structure
        throw new Error(`Content generation blocked: ${data.promptFeedback.blockReason}`);
      }
      if (!data.candidates || data.candidates.length === 0) {
        console.warn('No candidates returned from API.');
        throw new Error('No content generated by the API.');
      }

      return data;
    } catch (error) {
      console.error('Error calling Gemini API:', error);
      throw error; // Re-throw to be caught by the caller
    }
  }

  // Basic API connectivity test
  async checkAPIConnection(apiKey: string, model: string = 'gemini-pro'): Promise<{ ok: boolean; message: string; error?: any }> {
    const testPayload: GeminiRequestPayload = {
        contents: [{ role: 'user', parts: [{ text: "Hello" }] }],
        generationConfig: { maxOutputTokens: 2 } // Minimal response
    };
    try {
        const response = await this.generateContent(model, testPayload, apiKey);
        if (response.candidates && response.candidates.length > 0) {
            return { ok: true, message: "API connection successful." };
        } else {
            return { ok: false, message: "API connected but no response candidates.", error: response };
        }
    } catch (error: any) {
        return { ok: false, message: `API connection failed: ${error.message}`, error };
    }
  }
}

// --- Storage Service ---

const APP_STATE_KEY = 'geminiChatAppState';
const ARCHIVED_CHATS_KEY = 'geminiChatArchivedChats';

export interface ArchivedChat {
  id: string;
  timestamp: number;
  summary: string; // e.g., first user message
  conversation: ChatMessage[];
  appStateSnapshot: Partial<AppStateData>; // Store model, instructions etc. with the chat
}

export class StorageService {
  // App State
  loadState(): Partial<AppStateData> | null {
    try {
      const serializedState = localStorage.getItem(APP_STATE_KEY);
      if (serializedState === null) {
        return null;
      }
      return JSON.parse(serializedState);
    } catch (error) {
      console.error('Error loading state from localStorage:', error);
      return null;
    }
  }

  saveState(state: AppStateData): void {
    try {
      const serializedState = JSON.stringify(state);
      localStorage.setItem(APP_STATE_KEY, serializedState);
    } catch (error) {
      console.error('Error saving state to localStorage:', error);
    }
  }

  clearState(): void {
    try {
      localStorage.removeItem(APP_STATE_KEY);
    } catch (error) {
      console.error('Error clearing state from localStorage:', error);
    }
  }

  // Archived Chats
  loadArchivedChats(): ArchivedChat[] {
    try {
      const serializedChats = localStorage.getItem(ARCHIVED_CHATS_KEY);
      if (serializedChats === null) {
        return [];
      }
      return JSON.parse(serializedChats);
    } catch (error) {
      console.error('Error loading archived chats from localStorage:', error);
      return [];
    }
  }

  saveArchivedChats(chats: ArchivedChat[]): void {
    try {
      const serializedChats = JSON.stringify(chats);
      localStorage.setItem(ARCHIVED_CHATS_KEY, serializedChats);
    } catch (error)
      console.error('Error saving archived chats to localStorage:', error);
    }
  }

  archiveChat(chat: ArchivedChat): void {
    const chats = this.loadArchivedChats();
    chats.unshift(chat); // Add to the beginning
    this.saveArchivedChats(chats);
  }

  deleteArchivedChat(chatId: string): void {
    let chats = this.loadArchivedChats();
    chats = chats.filter(chat => chat.id !== chatId);
    this.saveArchivedChats(chats);
  }
}
